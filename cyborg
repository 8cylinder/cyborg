#!/usr/bin/env python3

import os
import sys
import re
import argparse
import textwrap
import datetime
import subprocess
import configparser
import socket
from pprint import pprint as pp

try:
    import click
except ModuleNotFoundError:
    class Click:
        def echo(self, msg, **kwargs):
            sys.stdout.write(msg)
        def secho(self, msg, **kwargs):
            sys.stdout.write(msg)
        def style(self, msg, **kwargs):
            return msg
    click = Click()


def log(msg, msg_type='info'):
    dt = datetime.datetime.now()
    timestamp = dt.strftime('%y-%m-%d %X')
    timestamp = click.style(timestamp, fg='blue')
    msg_types = {
        'info': ['INFO', 'green'],
        'error': ['STDERR', 'red'],
        'cmd': ['CMD', 'yellow'],
    }
    status = msg_types[msg_type][0]
    color = msg_types[msg_type][1]
    status = click.style(status, fg=color, bold=True)
    msg = click.style(msg, fg=color)
    out = f'{timestamp} :: {status} :: {msg}'
    click.secho(out)

def log_error(msg):
    log(msg, msg_type='error')

def log_cmd(msg):
    msg = ' '.join(msg)
    log(msg, msg_type='cmd')

def error(msg):
    log_error(msg)
    notify(msg)
    sys.exit(1)

def run_prog(cmd):
    log_cmd(cmd)
    result = subprocess.run(cmd,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)
    # pp(result)
    result.stdout = result.stdout.decode('utf-8').strip()
    # if result.stdout:
        # log(result.stdout.decode('utf-8').strip())
    if result.stderr:
        # error(result.stderr.decode('utf-8').strip())
        log(result.stderr.decode('utf-8').strip(), msg_type='error')
    if result.returncode:
        error(f'return code: {result.returncode}, command: {result.args}')
    return result

def notify(msg):
    cmd = ['/home/sm/bin/cron-notify-send', msg]
    result = subprocess.run(cmd,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)

class Borg:
    settings_file = os.path.expanduser('~/.cyborg/cyborg.ini')
    installed_apps = os.path.expanduser('~/.cyborg/installed-apps.txt')
    exclude_list = os.path.expanduser('~/.cyborg/exclude')

    def __init__(self, dry_run=True):
        self.dry_run = '--dry-run'
        if not dry_run:
            self.dry_run = ''

        # load settings file
        settings = self.load_settings()

        # check all file/dir existence
        self.check_file(self.destination)
        self.check_file(self.exclude_list)

    def check_file(self, filename):
        if not os.path.exists(filename):
            error(f'file does not exist: {filename}.')

    def load_settings(self):
        config = configparser.SafeConfigParser(inline_comment_prefixes=('#',))
        try:
            config.read(self.settings_file)
        except configparser.ParsingError as e:
            error(' '.join(str(e).split()))
        try:
            settings = config['settings']
        except KeyError as e:
            error(f'{self.settings_file} does not exist or does not contain a "[settings]" section.')
        try:
            self.backup_name = settings['backup_name'].strip('"\'')
            destination = settings['destination'].strip('"\'')
            self.remote_destination = settings['remote_destination'].strip('"\'')
        except KeyError as e:
            error(f'Missing key in {self.settings_file}: {e}')
        self.destination = self.fix(destination)

    def fix(self, path):
        path = os.path.expanduser(path)
        # path = os.path.normpath(path)
        return path

    def status(self):
        # show a list of all backup sets
        cmd = ['borg', 'list', self.destination]
        result = run_prog(cmd)
        print(result.stdout)
        output = result.stdout
        last_backup = output.split('\n')[-1].split()[0]
        print()

        # show details on the last backup set
        cmd = ['borg', 'info', '-v', f'{self.destination}::{last_backup}']
        result = run_prog(cmd)
        print(result.stdout)

    def run(self):
        # check if borg is running
        result = run_prog(['pidof', '-sx', 'borg'])
        if not result.returncode:
            error('Borg already running, aborting this backup.')

        # generate list of installed applications
        result = run_prog(['/home/sm/bin/backup-apps-list'])
        with open(self.installed_apps, 'w') as f:
            f.write(result.stdout)
            log(f'Wrote {self.installed_apps}')

        # backup
        dt = datetime.datetime.now()
        timestamp = dt.strftime('%Y-%m-%d__%H-%M')
        archive_name = f'{self.destination}::{socket.gethostname()}__{timestamp}'
        log(f'Starting backup to {archive_name}')
        cmd = ['borg', 'create', self.dry_run, '-v',
               f'--exclude-from={self.exclude_list}',
               '--compression=zlib,6',
               archive_name,
               os.path.expanduser('~')
        ]
        # Copy cmd array and remove any empty items, this causes and error if not.
        cmd = [i for i in cmd if i]
        result = run_prog(cmd)
        self.rclone()

    def rclone(self):
        result = run_prog(['pidof', '-sx', 'rclone'])
        if not result.returncode:
            error('rclone already running, aborting this remote upload.')
        log(f'Starting remote backup to {self.remote_destination}')
        cmd = ['rclone', self.dry_run, 'sync', '-v', self.destination, self.remote_destination]
        cmd = [i for i in cmd if i]
        result = run_prog(cmd)
        print(result)

    def extras(self):
        """Print out extra commands that can be copied and pasted to the command line"""
        commands = [
            ['init --dry-run', '--encryption=none', self.destination],
            ['restore --dry-run', self.destination, '# CAUTION, restores to cur dir only'],
            ['break-lock', self.destination],
            ['list', self.destination],
            ['check', self.destination, '# note: takes a long time'],
            ['mount', self.destination, 'MOUNTPOINT'],
            ['umount', 'MOUNTPOINT'],
        ]
        print()
        click.secho('https://borgbackup.readthedocs.io', fg='blue', underline=True)
        click.secho('https://github.com/borgbackup/borg', fg='blue', underline=True)
        print()
        for c in commands:
            cmd = ' '.join(c)
            click.secho(f'borg {cmd}', fg='yellow')


def init(args):
    try:
        borg = Borg(args.dry_run)
    except AttributeError:
        borg = Borg()
    result = getattr(borg, args.subparser_name)()


if __name__ == '__main__':
    help_msg = textwrap.dedent('''
        Backup using Borg

        https://borgbackup.readthedocs.io/en/stable/
        https://github.com/borgbackup''')

    parser = argparse.ArgumentParser(
        description=help_msg,
        formatter_class=argparse.RawDescriptionHelpFormatter)
    subparsers = parser.add_subparsers(dest='subparser_name')

    # run
    run = subparsers.add_parser('run', help='Run the backup')
    run.add_argument('-d', '--dry-run', action='store_true')
    run.add_argument('-r', '--remote', action='store_true')

    # status
    status = subparsers.add_parser('status', help='Check the backup')

    # rclone
    rclone = subparsers.add_parser('rclone', help='Use rclone to copy the repo to remote storage')
    rclone.add_argument('-d', '--dry-run', action='store_true')

    # extras
    extras = subparsers.add_parser('extras', help='Output extra commands to be copied and pasted in the terminal')

    args = parser.parse_args()
    init(args)

"""
cyborg run [--dry-run]
cyborg rsync [--dry-run]
cyborg status

cyborg init [--dry-run]
cyborg restore [--dry-run] ARCHIVENAME RESTOREPOINT
cyborg break [--dry-run]
cyborg list
cyborg check

borg create -v --exclude-from /home/sm/bin/backup-linux-filelist-borg.txt --compression zlib,6 /home/sm/net1/borgtest/::ubuntu-desktop__2019-01-05__11-04 /home/sm
borg create -v --exclude-from=/home/sm/bin/backup-linux-filelist-borg.txt --compression=zlib,6 /home/sm/net1/borgtest ::ubuntu-desktop__2019-01-05__11-03 /home/sm
"""
